puts "hello world"

def elevator
  floor = 0
  destinations = []
  add_destination = gets.chomp.to_i

  #needs to constantly assess against current floor in order to determine next destination
  current_floor = nil

  #if it's going up or down will need to do different assessment of current floor
  direction = nil
  while

  end

end

=begin
Write a method that takes an array of integers and an integer to search for. The method should return the index of the item, or nil if the integer is not present in the array. Don't use built-in array methods like .index. You are allowed to use .length and .each.

Here's an example of how we might use your method (assuming you call it search_array):

arr = [42, 89, 23, 1]
p search_array(arr, 1)
=> 3
p search_array(arr, 24)
=> nil
=end

arr = [1, 2, 3, 4, 5]



def search_array(arr, x)
  idx = 0
  result = nil
  arr.each do
    if arr[idx] == x
      result = idx
    end
    idx += 1
  end
  return result
end

p search_array(arr, 3)
p search_array(arr, 7)

arr = [42, 89, 23, 1]
p search_array(arr, 1)
#=> 3
p search_array(arr, 24)
#=> nil


=begin
Add a method to your file that takes a number of Fibonacci terms to generate and returns an array of the terms. For example, fib(6) would return [0,1,1,2,3,5]. Your method should work for a large number of terms. To verify your work: the last number in the array generated by fib(100) will be 218922995834555169026. (How can you verify this without having to compare this huge number manually? Be smart with your driver code!)
=end

def fibonacci_gen(x)
  fib = [0, 1,]
  idx = 0
  (x - 2).times do
    fib_value = fib[idx]  + fib[idx + 1]
    fib.push(fib_value)
    idx += 1
  end
  return fib
end

p fibonacci_gen(6)
p fibonacci_gen(100)
p fibonacci_gen(100)[99]  == 218922995834555169026
